Haiyun Jin
hjin38@wisc.edu

Testcases Design:
  0. Added Scan at the beginning of the page. PASSED
  1. test4(). Test on reading old index file. PASSED
  2. test6(). Test on reading bad index file. PASSED
  3. test5(). Test split non-leaf node using small page size. PASSED
              Need to change the page.h file and re-compile.
  4. test55(). Test split non-leaf node with large entries.   PASSED
              The string is %05d format in entries, however, to test on the 
          non-leaf split, need at least 340*680, the stringScan method are 
          modified to include %010d in stringScanLarge. 500000 entries are 
          used to test. CAUTION the test takes about 30 seconds.


Design:

The insertion of new records is implemented as a bottom-up fashion. It is 
designed as following:

findLeafNode():
    Given a page number amd Key, find the leaf node that this Key should be 
inserted. If the page is non-leaf page, find the page number that may contain 
the key and recursively call findLeafNode.

findParentOf():
    Given a page number and the last key in this page, find the parent page that
has this page number as one of its pointers. This is preferred to using a
parentPageNo field in the page structure because we don't need to update the
field when split. Although it takes some time to find the page, it will not
flush the buffer.

insertLeafNode():
    Insert a Key-Rid pair into a leaf node, if the node need to be splitted, 
call splitLeafNode() to split the node and add the key-rid pair the the proper
node after splitted.

insertNonLeafNode():
    Designed to be called by splitLeafNode/splitNonLeafNode only since only a
split in leaf/non-leaf results new non-leaf entries that need to be
copied/pushed into a non-leaf node. Similar implementation with insertLeafNode.

splitLeafNode():
    Called by insertLeafNode when there is no enough space in that node. It 
deals with two cases. One, if this leaf is not the root, it will split, use the
first key in the second node and the page number of the second node and a 
Key-PageNo pair, then it calls insertNonLeafNode to insert this pair into its
parent page. Two, if the leaf itself is the root, then it will create a new 
non-leaf node and try to insert the pair to new root.

splitNonLeafNode():
    Similar to splitLeafNode, it is called by insertNonLeafNode when there is no
enough space to insert. It will choose a pivot, and split the node into three 
part: left part, pivot, and right part. It allocates a new page and move the 
right part into the new page, updates the pages pointed by right part's keys's
parentNodeNo into the newly allocated PageId. The pivot key and the newly
allocated PageId forms a key-page pair. Then it will call insertNonLeafNode to
insert this pair to its parent page.

compare<T>(a, b):
Due to the type difference between Integer/Double and String, a generic compare
and a generic copyKey methods are used. The method, returns negative number, 
zero, and positive number when a is smaller than, equal to and large than b.

copyKey(dest, src):
Copy the content that src pointer points to the address that dest pointer 
points.

The pages in buffer are unpinned as soon as possible except when scanExecuting
is true. In the later case, the current page pinned until all records in the
page have been accessed or end of the scan. This choice is to ensure that the
current page will not be unpinned and replaced by any other pages. On the othet
hand, there will only one page being pinned thus will not lead to significant
buffer overuse.

My implementation is quite efficient. The entries in B+Tree are sorted and each
leaf page are linked by the previous page and points to next. This allows the
scan of keys without traversing the whole tree. In addition, two additional 
optimizations are made:
  1. To efficiently insert and delete, one additional field is added to the leaf
node and non-leaf node: int size. This is used to mark the number of keys in
this node. With this field, we don't have to clear the memory whenever nodes are
splited or in record is deleted, or scan the whole page to determine the size.
This space-time trade-off worth this efficiency brought.
  2. To efficiently locate a key, binary search (getIndex()) is used to find the
position instead of linear scan. getIndex finds the first key that is not
smaller than the given key value.

The assumption that no duplicated key is allowed simplifies the implementation
in that we are assured that the leaf node will only store rids such that the
leaf node has uniform format and we can use only an array to point to the right
position.
If duplicate keys are allowed, we have to change the format of the leaf node
such that each key corresponding to a list pointer that points to a list that
store a or several rids that points the same key, or called overflow pages.

Additional design choice:
  1. during the scan, nextEntry is updated by shiftToNextEntry function. This
function behaves as normal nextEntry++ but does additional work. First, if the
nextEntry is already the last key in the current page. In later case, it will
change the currentPageNum and currentPageData field to the next leaf page and
set nextEntry as zero. Second, it will check if the endScan condition is met,
and signal the caller if the scan is done.

